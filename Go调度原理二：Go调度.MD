# Go调度原理二：Go调度

## 介绍
在该系列的第一篇文章中，我们已经解释了操作系统调度的各个方面，我认为这对理解和欣赏Go调度的语义非常重要。在这一部分，我将从语义层面讲一下Go的调度是如何进行的。Go调度调度本身其实很复杂，很多细节不用过分关注，重要的是通过一个模型来理解Go的调度机制，这有助于在实践中做出更好的决策。

## 程序启动

Go启动后会为其分配一个逻辑处理器 (Logical Processor，P)。对于一台机器而言，逻辑处理器的数量是由机器的虚拟核心决定的，有几个虚拟核心就有几个逻辑处理器。而虚拟核心数又和CPU的架构有关的。比如下面这个机器的硬件配置，显示有1个处理器，6个物理核心。理论上一个物理核只会有一个物理线程，但是由于Inter Core i7 的CPU有超线程技术，也就是说一个物理核可以有2个物理线程。所以这个机器实际上有12个物理线程，也可以认为是有12个虚拟核心，也就是说有12个逻辑处理器。

## 协作调度

在上一篇已经讲过，操作系统的调度是抢占式调度，这意味着，本质上而言，没法预知在某个给定的时间调度程序将会执行啥操作。所有的工作都是内核来完成的，运行在操作系统之上的应用程序无法通过调度来控制内核内部发生的事情，除非它调用类似于 atomic 或者 mutex 这样的同步原语。

Go调度则是Go运行时的一部分，并且Go运行时已经内置到应用程序里面。这意味着Go调度运行在用户空间，处在操作系统内核之上。并且，Go调度的实现并不是抢占式的，而是协作式的。协作式调度意味着需要在应用程序中合理的设计调度方案。

但是在实践中你可能感觉到Go调度好像也是抢占式的呀，毕竟我们还是无法预测调度程序将要执行啥操作呀，这是因为该调度程序的决策权并不在开发人员，而是在Go运行时。

## Go协程状态

和操作系统线程一样，Go协程也有三种状态，这决定了Go调度器在任意给定Go协程中的角色。一个Go协程可以处于三种状态：Waiting，Runnable，Executing。
- Waiting - 意味着Go协程已暂停，并且在等待一个时机以继续执行。处于这种状态可能是因为在等待操作系统(系统调用)或者同步调用(原子或互斥操作)。这些类型的延迟是导致性能下降的根本原因。
- Runnable - 这意味着Go协程需要M给它分配时间从而执行分配给该协程的指令。如果有很多需要分配时间的Go协程，那意味着Go协程必须等待更长的时间才能执行。而且，随着更多Goroutine争夺时间，分配给单个Goroutine的时间必将缩短。这种类型的调度延迟也可能是性能下降的原因。
- Executing - 这意味着Go协程已经被置于M(也就是分配到了时间)并且在执行指令。与应用程序相关的工作正在完成。 这是每个人都想要的状态。


## 上下文切换
Go调度程序需要定义明确的用户空间事件，这些事件发生在代码中的安全点处，以便从上下文进行切换。 这些事件和安全点在函数调用中体现出来。 函数调用对于Go调度程序的运行状况至关重要。 今天（使用Go 1.11或更低版本），如果运行任何未进行函数调用的密集循环，将会导致调度程序和垃圾回收中的延迟。 在合理的时间范围内进行函数调用至关重要。

>注意：有一个建议1.12已被接受，可以在Go调度程序中应用非合作式抢占技术，以允许抢占紧密循环。

在GO程序中，四种类型的事件会让调度器进行调度决策。这并不意味着它将永远在这些事件之一中发生。只是意味着调度程序有机会发生。

- 使用go关键字
- 垃圾收集
- 系统调用
- 同步与编排

### 使用go关键字
关键字go是用来创建协程的，一旦一个新的协程被创建，会使得调度器有机会做调度决策。
### 垃圾收集
由于GC使用自己的Goroutine集合运行，因此这些Goroutine需要M上的时间才能运行。 这导致GC造成很多调度混乱。 但是，调度程序非常聪明，它知道Goroutine正在做的事情，它会据此做出明智的决策。 其中一个明智的决定是在GC时对要触及堆的Goroutine与不触及堆的Goroutine进行上下文切换。 当GC运行时，会制定很多决策。
### 系统调用
如果Go协程发起一个系统调用则会阻塞整个M，调度器有时候有能力将Go协程从M上切换出来，并将新的Go协程切换到该M上。然而，有时需要一个新的M来继续执行在P中排队的Goroutine。但是这些会在下一节中更深入的讲述。
### 同步与编排
如果原子，互斥或通道操作调用导致Goroutine阻塞，则调度程序可以上下文切换运行新的Goroutine。 一旦被阻塞的Goroutine可以再次运行，就可以对其重新编排，并最终在M上进行上下文切换。
异步系统调用
当您正在运行的OS能够异步处理系统调用时，可以使用称为网络轮询器的东西来更有效地处理系统调用。 这是通过在各个操作系统中使用kqueue（MacOS），epoll（Linux）或iocp（Windows）来完成的。
我们今天使用的许多操作系统都可以异步处理基于网络的系统调用。 这也是网络轮询器得名的原因，这是因为它的主要用途是处理网络操作。 通过使用网络轮询器进行网络系统调用，调度程序可以避免Goroutine在进行这些系统调用时阻止M。 这有助于使M保持可用以执行P的LRQ(Local Run Queue)中的其他Goroutine，而无需创建新的M。这有助于减少OS上的调度负载。

理解这个过程的最好方式是使用一个例子：
