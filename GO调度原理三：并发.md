# GO调度原理三：并发


### 什么是并发
**并发**的意思就是“**乱序执行**”，对一组本来应该顺序执行的指令，以某种方式乱序地执行他们并得到同样的输出结果。对于摆在你面前的问题而言，乱序执行显然会增加价值。这里所说的价值是指，以增加复杂性为代价来换取更好的性能。当然主要还是取决于你所面对的问题，可能有时候乱序执行并不可行或者不会带来任何收益。

同样需要理解的是**并发并不是并行**。并行意味着同时执行2个或者更多的指令。这与并发的概念是不同的。并行只有在你拥有至少2个操作系统线程(硬件线程)并且有2个Go协程，每个Go协程运行在独立的操作系统线程的情况下才有可能。


### 负载
那么我们怎么知道什么时候乱序执行可以给我们带来收益呢？可以从你的应用程序所处理的负载类型来入手。当考虑到并发的时候，理解2种不同类型的负载非常重要。

- **CPU约束型**(**CPU-Bound**，或**CPU密集型**) - 这种类型的负载永远不可能导致Go协程自然的进入/离开Waiting状态。这类工作一般是持续的进行计算工作。计算Pi小数点后N位可以视为一个CPU约束型工作。
- **I/O约束型**(**I/O-Bound**，或**I/O密集型**) - 这种类型的负载会导致Go协程自然的进入到**Waiting**状态。这种工作通常是通过网络请求访问资源或者发起操作系统调用或者等待某个事件发生。一个需要读取文件的Go协程可视为I/O约束型的。这里我会把可以导致Go协程进入等待状态的同步事件(mutexes, atomic)也归为这一类。

如果负载是**CPU约束型**的，那你**需要**并行地调用并发。对于这种类型的负载，由于Go协程不会自然的进入/离开**Waiting**状态。所以在这种情况下用单个OS/硬件线程来跑多个Go协程是低效的，会降低负载的处理速度。因为把Go协程切入和切出OS线程上会造成延迟。这种场景下的上下文切换会产生“**暂停世界**(**Stop The World**)”这种效果，因为在上下文切换这段时间，任何负载工作都不会被执行。


而如果负载是**I/O约束型**的，那你**无需**并行地调用并发。对于 这种类型的负载，由于Go协程会自然的进入/离开**Waiting**状态。所以在这种情况下用单个OS/硬件线程来跑多个Go协程是非常高效的，会加速负载的处理速度。因为把Go协程切入和切出OS线程不会产生“**暂停世界**(**Stop The World**)” 这种效果，因为在上下文切换时，前一个Go协程是自然暂停的，新的Go协程会切入OS/硬件线程执行，不会导致该OS/硬件线程闲置。

> 提示：什么意思呢？
> 
> 也就是说，对于CPU密集型任务而言，本身不希望中途被打断，所以频繁上下文切换会打断执行，降低效率。
>
> 而对于I/O密集型任务而言，本身就会有暂停的时候。在暂停的时候将其移出OS线程同时移入其它Go协程处理并不会带来损失，反而可以提高效率。


那我们怎么知道每个OS/硬件线程跑多少个Go协程可以带来最佳的吞吐量呢？Go协程太少会导致OS线程空闲时间变多，而Go协程太多则会导致上下文切换带来的延迟增加。这是你需要思考的问题，本文不会做过多的讨论。

此刻，有必要用一些例子来巩固一下你对哪种情况适合用并发，哪种情况不适合以及是否需要用并行的判别能力了。
### 求和
我们不需要特别复杂的例子来描述这些场景，使用下面这个简单的求和函数的例子就可以：

**Listing 1**

	func add(numbers []int) int {
	   var v int
	   for _, n := range numbers {
	       v += n
	   }
	   return v
	}

**Listing 1** 中是一个求和函数`add`，接受一个`int`数组返回数组所有元素的和。

**问题**：这个add函数所负责的工作是否适合乱序执行？我认为答案是适合。这个数组可以拆分成小数组然后并发的执行。一旦所有的小数组都求和完成后，将他们的结果加起来就是最终的结果，和直接求和结果一样。

然而，这会儿会有另外一个问题浮现。需要拆成多少数组才能达到最佳的吞吐呢？要回答这个问题，你需要先了解`add`函数属于哪种负载。`add`函数实际上是一种CPU约束型负载。因为它这个算法执行的是纯数学计算，任何时候都不会导致Go协程自然的进入到Waiting状态。这意味着每个OS/硬件线程跑一个Go协程就能达到很好的性能。

**Listing 2** 中是实现的一个并发版求和函数`addConcurrent`

> 注意：有很多种方式实现并发版的add，这里只是做个示例。

**Listing 2** 

	44 func addConcurrent(goroutines int, numbers []int) int {
	45     var v int64
	46     totalNumbers := len(numbers)
	47     lastGoroutine := goroutines - 1
	48     stride := totalNumbers / goroutines
	49
	50     var wg sync.WaitGroup
	51     wg.Add(goroutines)
	52
	53     for g := 0; g < goroutines; g++ {
	54         go func(g int) {
	55             start := g * stride
	56             end := start + stride
	57             if g == lastGoroutine {
	58                 end = totalNumbers
	59             }
	60
	61             var lv int
	62             for _, n := range numbers[start:end] {
	63                 lv += n
	64             }
	65
	66             atomic.AddInt64(&v, int64(lv))
	67             wg.Done()
	68         }(g)
	69     }
	70
	71     wg.Wait()
	72
	73     return int(v)
	74 }
