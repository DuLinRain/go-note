# GO调度原理三：并发


### 什么是并发
**并发**的意思就是“**乱序执行**”，对一组本来应该顺序执行的指令，以某种方式乱序地执行他们并得到同样的输出结果。对于摆在你面前的问题而言，乱序执行显然会增加价值。这里所说的价值是指，以增加复杂性为代价来换取更好的性能。当然主要还是取决于你所面对的问题，可能有时候乱序执行并不可行或者不会带来任何收益。

同样需要理解的是**并发并不是并行**。并行意味着同时执行2个或者更多的指令。这与并发的概念是不同的。并行只有在你拥有至少2个操作系统线程(硬件线程)并且有2个Go协程，每个Go协程运行在独立的操作系统线程的情况下才有可能。


### 负载
那么我们怎么知道什么时候乱序执行可以给我们带来收益呢？可以从你的应用程序所处理的负载类型来入手。当考虑到并发的时候，理解2种不同类型的负载非常重要。

- **CPU约束型**(**CPU-Bound**，或**CPU密集型**) - 这种类型的负载永远不可能导致Go协程自然的进入/离开Waiting状态。这类工作一般是持续的进行计算工作。计算Pi小数点后N位可以视为一个CPU约束型工作。
- **I/O约束型**(**I/O-Bound**，或**I/O密集型**) - 这种类型的负载会导致Go协程自然的进入到**Waiting**状态。这种工作通常是通过网络请求访问资源或者发起操作系统调用或者等待某个事件发生。一个需要读取文件的Go协程可视为I/O约束型的。这里我会把可以导致Go协程进入等待状态的同步事件(mutexes, atomic)也归为这一类。

如果负载是CPU约束型的，那你**需要**并行地调用并发。


而如果负载是I/O约束型的，那你**无需**并行地调用并发。
